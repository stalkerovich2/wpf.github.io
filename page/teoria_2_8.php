<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content1-type" content1="text/html; charset=windows-1251" /> 
<meta http-equiv="content1-type" content1="text/html; charset=utf8" />
<link href= "../css/style.css" rel="stylesheet">
<title>Главная</title>
    </head>
<body>
		<?php require("../inc/head.inc");?>
		<?php require("../inc/hleb.inc");?>
<table	class="table_verst">
    <tr>		
		<td class="menu">		
	<?php require("../inc/left_meny.inc");?>	
			</td>
        <td class="content1">
		<div  class="zaglav">Пользовательские элементы управления WPF</div>
<p>Хотя пользовательский элемент можно построить в любом проекте WPF, обычно такие элементы размещаются в специально выделенной сборке — библиотеке классов (DLL). Это позволяет разделять работу с множеством приложений WPF.</p>
<p>Чтобы гарантировать наличие всех необходимых ссылок на сборки и импорт всех нужных пространств имен, при создании приложения в Visual Studio в качестве типа проекта следует выбрать Custom Control Library (WPF) (Библиотека пользовательских элементов управления (WPF)). Внутри библиотеки классов можно создавать сколько угодно элементов управления.</p>
<p>Как при разработке любой библиотеки классов, часто стоит помещать как саму библиотеку классов, так и приложение, использующее ее, в одно и то же решение Visual Studio. Это позволит легко модифицировать и отлаживать обе части вместе.</p>
<p>Первый шаг в создании пользовательского элемента управления — это выбор корректного базового класса для наследования. Ниже перечислены некоторые часто применяемые классы для создания пользовательских элементов управления, а на (<a href="#r1">Рис. 1 </a>) показано их расположение в иерархии элементов:</p>
<ul id="spisok">
	<li>FrameworkElement;</li>
	<li>Control;</li>
	<li>ContentControl;</li>
	<li>UserControl;</li>
	<li>ItemsControl и Selector;</li>
	<li>Panel;</li>
	<li>Decorator.</li>
</ul>
<p><a  style="color: #ff6600;"><strong>FrameworkElement</strong></a> - это самый низкий уровень, с которым обычно приходится иметь дело при создании пользовательского элемента. Обычно такой подход выбирается только тогда, когда нужно нарисовать его содержимое "с нуля" посредством переопределения OnRender() и использования System.Windows.Media.DrawingContext. Это похоже на подход, где пользовательский интерфейс конструировался на основе объектов Visual. Класс FrameworkElement предоставляет лишь самый базовый набор свойств и событий для элементов, которые не предназначены для взаимодействия с пользователем.</p>
<p><a  style="color: #ff6600;"><strong>Control</strong></a> - базовый класс для всех взаимодействующих с пользователем графических элементов управления. Класс Control добавляет свойства для установки фона и переднего плана, а также шрифта и выравнивания содержимого. Кроме того, этот класс помещает себя в последовательность обхода по клавише <Tab> (свойством IsTabStop) и получает уведомления о двойном щелчке (через события MouseDoubleClick и PreviewMouseDoubleClick). Но что более важно, так это то, что класс Control определяет свойство Template, позволяющее заменять его внешний вид с неограниченной гибкостью.</p>
<p><a  style="color: #ff6600;"><strong>ContentControl</strong></a> - базовый класс для элементов управления, которые могут отображаться как единое целое с произвольным содержимым. Содержимое может быть элементом пользовательского объекта, применяемого в сочетании с шаблоном. (Содержимое устанавливается свойством Content, а необязательный шаблон может быть представлен в свойстве ContentTemplate.) Многие элементы управления упаковывают специфический, ограниченный тип содержимого (вроде строки текста в текстовом поле). Поскольку эти элементы управления не поддерживают всех элементов, они не должны определяться как элементы управления с содержимым.</p>
<p><a  style="color: #ff6600;"><strong>UserControl</strong></a> - Это элемент управления с содержимым, который может быть сконфигурирован с применением поверхности времени проектирования. Хотя такой пользовательский элемент управления не настолько отличается от обычного элемента управления с содержимым, обычно он используется тогда, когда необходимо быстро повторно применить неизменный блок пользовательского интерфейса в более чем одном окне (вместо создания действительно отдельного элемента управления, который может быть перенесен из одного приложения в другое).</p>
<p><a  style="color: #ff6600;"><strong>ItemsControl и Selector</strong></a> - ItemsControl — базовый класс для элементов управления, служащих оболочками для списков элементов, но не поддерживающих выбор позиций, в то время как Selector — более специализированный базовый класс для элементов, поддерживающих выбор. Эти классы нечасто применяются для создания пользовательских элементов управления, поскольку средства шаблонов данных ListBox, ListView и TreeView обеспечивают достаточную гибкость.</p>
<p><a  style="color: #ff6600;"><strong>Panel</strong></a> - базовый класс для элементов управления, обладающих логикой компоновки. Элемент с компоновкой может содержать в себе множество дочерних элементов и размещать их в соответствии с определенной семантикой компоновки. Часто панели включают присоединенные свойства, которые могут быть установлены в дочерние элементы для того, чтобы конфигурировать их расположение.</p>
<p><a  style="color: #ff6600;"><strong>Decorator</strong></a> - это базовый класс для элементов, служащих оболочками для других элементов и обеспечивающих графический эффект или определенное средство. Двумя яркими примерами могут служить Border, который рисует линию вокруг элемента, и Viewbox, масштабирующий свое содержимое динамически с использованием трансформаций. Среди других декораций — классы Chrome, служащие для снабжения знакомыми рамками и фоном часто используемых элементов управления, таких как кнопка.</p>
<div id="statya">
	<h3 id="r1">Рис. 1 Иерархия компонентов управления</h3>
   <img id="img" src="../img/r1_4_2.png">
</div>
<p><a  style="color: #ff6600;"><strong>Специфический класс элемента</strong></a>. Если необходимо усовершенствовать существующий элемент управления, можно наследоваться непосредственно от класса этого элемента, управления. Например, можно создать элемент TextBox со встроенной логикой проверки достоверности. Однако прежде чем предпринять такой шаг, подумайте, нельзя ли достичь той же цели с помощью кода обработки событий или отдельного компонента. Оба подхода позволят отделить логику от элемента управления и применять ее в других элементах.</p>
<p>Хотя допускается построить специальный элемент, который не является элементом управления, большинство пользовательских элементов, создаваемых в WPF, будут именно элементами управления. Это значит, что они смогут принимать фокус, а также взаимодействовать с пользовательскими нажатиями клавиш и действиями мыши. По этой причине термины пользовательские элементы и пользовательские элементы управления при разработке WPF-приложений часто являются взаимозаменяемыми.</p>
	</td>
    </tr>	
</table>


</body>
</html>